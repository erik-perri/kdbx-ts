// Generated by dts-bundle-generator v9.5.1

export function benchmarkAes256KdfKey(targetMilliseconds: number): Promise<number>;
export declare const Argon2Type: Readonly<{
	readonly Argon2d: 0;
	readonly Argon2id: 2;
}>;
export type Argon2Type = (typeof Argon2Type)[keyof typeof Argon2Type];
export declare const Argon2Version: Readonly<{
	readonly V10: 16;
	readonly V13: 19;
}>;
export type Argon2Version = (typeof Argon2Version)[keyof typeof Argon2Version];
export function benchmarkArgon2KdfKey(targetMilliseconds: number, memoryInBytes?: bigint, parallelism?: bigint, type?: Argon2Type, version?: Argon2Version): Promise<number>;
export declare const KeePass2: Readonly<{
	readonly innerStreamSalsa20IV: Uint8Array<ArrayBuffer>;
	readonly signature1: 2594363651;
	readonly signature2: 3041655655;
	readonly variantMapCriticalMask: 65280;
	readonly variantMapVersion: 256;
}>;
export declare const SymmetricCipherDirection: Readonly<{
	readonly Decrypt: 0;
	readonly Encrypt: 1;
}>;
export type SymmetricCipherDirection = (typeof SymmetricCipherDirection)[keyof typeof SymmetricCipherDirection];
export declare const CompressionAlgorithm: Readonly<{
	readonly None: 0;
	readonly GZip: 1;
}>;
export type CompressionAlgorithm = (typeof CompressionAlgorithm)[keyof typeof CompressionAlgorithm];
export declare const KdfUuid: Readonly<{
	readonly AesKdbx3: "c9d9f39a-628a-4460-bf74-0d08c18a4fea";
	readonly AesKdbx4: "7c02bb82-79a7-4ac0-927d-114a00648238";
	readonly Argon2d: "ef636ddf-8c29-444b-91f7-a9a403e30a0c";
	readonly Argon2id: "9e298b19-56db-4773-b23d-fc3ec6f0a1e6";
}>;
export type KdfUuid = (typeof KdfUuid)[keyof typeof KdfUuid];
export declare const SymmetricCipherAlgorithm: Readonly<{
	readonly Aes256_CBC: "aes256_cbc";
	readonly Twofish_CBC: "twofish_cbc";
	readonly ChaCha20: "chacha20";
	readonly Salsa20: "salsa20";
}>;
export type SymmetricCipherAlgorithm = (typeof SymmetricCipherAlgorithm)[keyof typeof SymmetricCipherAlgorithm];
declare const VariantMapFieldType: Readonly<{
	readonly End: 0;
	readonly UInt32: 4;
	readonly UInt64: 5;
	readonly Bool: 8;
	readonly Int32: 12;
	readonly Int64: 13;
	readonly String: 24;
	readonly ByteArray: 66;
}>;
export type VariantMapFieldType = (typeof VariantMapFieldType)[keyof typeof VariantMapFieldType];
declare const NullableBoolean: Readonly<{
	readonly Inherit: -1;
	readonly False: 0;
	readonly True: 1;
}>;
export type NullableBoolean = (typeof NullableBoolean)[keyof typeof NullableBoolean];
export type Database = {
	metadata: Metadata;
	root: DatabaseRoot;
};
export type Metadata = {
	binaries?: MetadataBinaries;
	color?: string;
	customData?: MetadataCustomData;
	customIcons?: MetadataCustomIcons;
	defaultUserName?: string;
	defaultUserNameChanged?: Date;
	description?: string;
	descriptionChanged?: Date;
	entryTemplatesGroup?: Uuid;
	entryTemplatesGroupChanged?: Date;
	generator?: string;
	headerHash?: Uint8Array;
	historyMaxItems?: number;
	historyMaxSize?: number;
	lastSelectedGroup?: Uuid;
	lastTopVisibleGroup?: Uuid;
	maintenanceHistoryDays?: number;
	masterKeyChangeForce?: number;
	masterKeyChangeRec?: number;
	masterKeyChanged?: Date;
	memoryProtection?: MemoryProtection;
	name?: string;
	nameChanged?: Date;
	recycleBinChanged?: Date;
	recycleBinEnabled?: boolean;
	recycleBinUuid?: Uuid;
	settingsChanged?: Date;
};
export type Uuid = string;
export type MetadataBinaries = Record<string, Uint8Array | undefined>;
export type MetadataCustomData = Record<string, CustomDataWithTimes | undefined>;
export type CustomData = {
	key: string;
	value: string;
};
export type CustomDataWithTimes = CustomData & {
	lastModified?: Date;
};
export type MetadataCustomIcons = Record<Uuid, Icon | undefined>;
export type Icon = {
	data: Uint8Array;
	lastModificationTime?: Date;
	name?: string;
	uuid: Uuid;
};
export type MemoryProtection = {
	protectTitle?: boolean;
	protectUserName?: boolean;
	protectPassword?: boolean;
	protectURL?: boolean;
	protectNotes?: boolean;
};
export type DatabaseRoot = {
	group: Group;
	deletedObjects?: DeletedObject[];
};
export type Group = {
	children?: Group[];
	customData?: Record<string, CustomData | undefined>;
	customIcon?: Uuid;
	defaultAutoTypeSequence?: string;
	enableAutoType?: NullableBoolean;
	enableSearching?: NullableBoolean;
	entries?: Entry[];
	iconNumber?: number;
	isExpanded?: boolean;
	lastTopVisibleEntry?: Uuid;
	name?: string;
	notes?: string;
	previousParentGroup?: Uuid;
	tags?: string;
	timeInfo?: TimeInfo;
	uuid: Uuid;
};
export type DeletedObject = {
	uuid: Uuid;
	deletionTime: Date;
};
export type Entry = {
	attachments?: Record<string, EntryAttachment | undefined>;
	attributes?: Record<string, EntryAttribute | undefined>;
	autoType?: AutoType;
	backgroundColor?: string;
	customData?: Record<string, CustomData | undefined>;
	customIcon?: Uuid;
	foregroundColor?: string;
	history?: Entry[];
	iconNumber?: number;
	overrideURL?: string;
	previousParentGroup?: Uuid;
	qualityCheck?: boolean;
	tags?: string;
	timeInfo?: TimeInfo;
	uuid: Uuid;
};
export type EntryAttachment = {
	data: Uint8Array;
	key: string;
	ref: string;
};
export type EntryAttribute = {
	isProtected: boolean;
	key: string;
	value: string;
};
export type TimeInfo = {
	creationTime?: Date;
	expires?: boolean;
	expiryTime?: Date;
	lastAccessTime?: Date;
	lastModificationTime?: Date;
	locationChanged?: Date;
	usageCount?: number;
};
export type AutoType = {
	enabled?: boolean;
	/**
	 * 0: No obfuscation.
	 * 1: Two-channel auto-type obfuscation.
	 */
	dataTransferObfuscation?: number;
	defaultSequence?: string;
	associations?: AutoTypeAssociation[];
};
export type AutoTypeAssociation = {
	window: string;
	sequence: string;
};
export type KdbxFile = {
	database: Database;
	innerHeader: KdbxInnerHeader;
	outerHeader: KdbxOuterHeader;
};
export type KdbxOuterHeader = {
	fields: KdbxOuterHeaderFields;
	signature: KdbxSignature;
};
export type KdbxSignature = {
	signature1: number;
	signature2: number;
	versionMajor: number;
	versionMinor: number;
};
export type KdbxOuterHeaderFields = {
	cipherAlgorithm: SymmetricCipherAlgorithm;
	compressionAlgorithm: CompressionAlgorithm;
	encryptionIV: Uint8Array;
	endOfHeader?: Uint8Array;
	kdfParameters: KdbxKdfParameters;
	masterSeed: Uint8Array;
	publicCustomData?: KdbxVariantMap;
};
export type KdbxVariantMapValue = {
	type: typeof VariantMapFieldType.End;
	value: never;
} | {
	type: typeof VariantMapFieldType.Bool;
	value: boolean;
} | {
	type: typeof VariantMapFieldType.Int32;
	value: number;
} | {
	type: typeof VariantMapFieldType.UInt32;
	value: number;
} | {
	type: typeof VariantMapFieldType.Int64;
	value: bigint;
} | {
	type: typeof VariantMapFieldType.UInt64;
	value: bigint;
} | {
	type: typeof VariantMapFieldType.String;
	value: string;
} | {
	type: typeof VariantMapFieldType.ByteArray;
	value: Uint8Array;
};
export type KdbxVariantMapValues = {
	[key: string]: KdbxVariantMapValue | undefined;
};
export type KdbxVariantMap = {
	values: KdbxVariantMapValues;
	version: number;
};
export type KdbxAesKdfParameters = {
	rounds: bigint;
	seed: Uint8Array;
	uuid: typeof KdfUuid.AesKdbx3 | typeof KdfUuid.AesKdbx4;
	variantMapVersion: number;
};
export type KdbxArgon2KdfParameters = {
	iterations: bigint;
	memoryInBytes: bigint;
	parallelism: bigint;
	seed: Uint8Array;
	type: Argon2Type;
	uuid: typeof KdfUuid.Argon2d | typeof KdfUuid.Argon2id;
	variantMapVersion: number;
	version: Argon2Version;
};
export type KdbxKdfParameters = KdbxAesKdfParameters | KdbxArgon2KdfParameters;
export type KdbxBinaryPoolValue = {
	data: Uint8Array;
	index: string;
	protectInMemory: boolean;
};
export type KdbxInnerHeader = {
	binaryPool?: KdbxBinaryPoolValue[];
	endOfHeader?: Uint8Array;
	innerEncryptionAlgorithm: SymmetricCipherAlgorithm;
	innerEncryptionKey: Uint8Array;
};
export type Dependencies = {
	cipherAes256?: SymmetricCipherFactory;
	cipherChaCha20?: SymmetricCipherFactory;
	cipherSalsa20?: SymmetricCipherFactory;
	cipherTwofish?: SymmetricCipherFactory;
	hash?: HashFactory;
	hmac?: HmacFactory;
	randomBytes?: (length: number) => Promise<Uint8Array>;
	transformAes256KdfKey?: TransformAes256KdfKey;
	transformArgon2KdfKey?: TransformArgon2KdfKey;
};
export type SymmetricCipher = {
	finish(data: Uint8Array): Promise<Uint8Array>;
	process(data: Uint8Array): Promise<Uint8Array>;
};
export type HashImplementation = {
	update(data: Uint8Array): HashImplementation;
	digest(): Uint8Array;
};
export type HashFactory = (algorithm: string) => Promise<HashImplementation>;
export type HmacImplementation = {
	update(data: Uint8Array): HmacImplementation;
	digest(): Uint8Array;
};
export type HmacFactory = (algorithm: string, key: Uint8Array) => Promise<HmacImplementation>;
export type SymmetricCipherFactory = (direction: SymmetricCipherDirection, key: Uint8Array, iv: Uint8Array) => Promise<SymmetricCipher>;
export type TransformAes256KdfKey = (key: Uint8Array, parameters: KdbxAesKdfParameters) => Promise<Uint8Array>;
export type TransformArgon2KdfKey = (key: Uint8Array, parameters: KdbxArgon2KdfParameters) => Promise<Uint8Array>;
export declare function configureDependencies(overrides: Partial<Dependencies>): void;
export declare const DefaultIconNumber: Readonly<{
	readonly Password: 0;
	readonly PackageNetwork: 1;
	readonly MessageBoxWarning: 2;
	readonly Server: 3;
	readonly Klipper: 4;
	readonly EduLanguages: 5;
	readonly KCMDF: 6;
	readonly Kate: 7;
	readonly Socket: 8;
	readonly Identity: 9;
	readonly Kontact: 10;
	readonly Camera: 11;
	readonly IrKickFlash: 12;
	readonly KGPGKey3: 13;
	readonly LaptopPower: 14;
	readonly Scanner: 15;
	readonly MozillaFirebird: 16;
	readonly CdromUnmount: 17;
	readonly Display: 18;
	readonly MailGeneric: 19;
	readonly Misc: 20;
	readonly KOrganizer: 21;
	readonly ASCII: 22;
	readonly Icons: 23;
	readonly ConnectEstablished: 24;
	readonly FolderMail: 25;
	readonly FileSave: 26;
	readonly NfsUnmount: 27;
	readonly QuickTime: 28;
	readonly KGPGTerm: 29;
	readonly Konsole: 30;
	readonly FilePrint: 31;
	readonly FSView: 32;
	readonly Run: 33;
	readonly Configure: 34;
	readonly KRFB: 35;
	readonly Ark: 36;
	readonly KPercentage: 37;
	readonly SambaUnmount: 38;
	readonly History: 39;
	readonly MailFind: 40;
	readonly VectorGfx: 41;
	readonly KCMMemory: 42;
	readonly EditTrash: 43;
	readonly KNotes: 44;
	readonly Cancel: 45;
	readonly Help: 46;
	readonly KPackage: 47;
	readonly Folder: 48;
	readonly FolderBlueOpen: 49;
	readonly FolderTar: 50;
	readonly Decrypted: 51;
	readonly Encrypted: 52;
	readonly Apply: 53;
	readonly Signature: 54;
	readonly Thumbnail: 55;
	readonly KAddressBook: 56;
	readonly ViewText: 57;
	readonly KGPG: 58;
	readonly PackageDevelopment: 59;
	readonly KFMHome: 60;
	readonly Services: 61;
	readonly Tux: 62;
	readonly Feather: 63;
	readonly Apple: 64;
	readonly W: 65;
	readonly Money: 66;
	readonly Certificate: 67;
	readonly Smartphone: 68;
}>;
export type DefaultIconNumber = (typeof DefaultIconNumber)[keyof typeof DefaultIconNumber];
export declare const HashAlgorithm: Readonly<{
	readonly Sha256: "sha256";
	readonly Sha512: "sha512";
}>;
export type HashAlgorithm = (typeof HashAlgorithm)[keyof typeof HashAlgorithm];
export declare const SymmetricCipherUuid: Readonly<{
	readonly Aes256: "31c1f2e6-bf71-4350-be58-05216afc5aff";
	readonly Twofish: "ad68f29f-576f-4bb9-a36a-d47af965346c";
	readonly ChaCha20: "d6038a2b-8b6f-4cb5-a524-339a31dbb59a";
}>;
export type SymmetricCipherUuid = (typeof SymmetricCipherUuid)[keyof typeof SymmetricCipherUuid];
export declare class KdbxError extends Error {
	constructor(message: string);
}
export declare class UnknownKdbxSignatureError extends KdbxError {
	constructor(message: string);
}
export declare class UnsupportedKdbxVersionError extends KdbxError {
	constructor(message: string);
}
export function createAesKdfParameters(rounds: bigint, seed?: Uint8Array): Promise<KdbxAesKdfParameters>;
export function createArgon2KdfParameters(iterations: bigint, memoryInBytes: bigint, parallelism: bigint, type: Argon2Type, seed?: Uint8Array): Promise<KdbxArgon2KdfParameters>;
export function createInnerHeaderEncryptionKey(cipher: SymmetricCipherAlgorithm): Promise<Uint8Array>;
export function createOuterHeaderEncryptionIV(cipher: SymmetricCipherAlgorithm): Promise<Uint8Array>;
export function createOuterHeaderMasterSeed(): Promise<Uint8Array>;
export function randomizeSeeds(file: KdbxFile): Promise<KdbxFile>;
declare const FileKeyType: Readonly<{
	readonly Hashed: 1;
}>;
export type FileKeyType = (typeof FileKeyType)[keyof typeof FileKeyType];
export type KdbxProcessedKey = {
	data: Uint8Array;
};
export type KdbxPasswordKey = KdbxProcessedKey;
export type KdbxFileKey = KdbxProcessedKey & {
	type: FileKeyType;
};
export type KdbxChallengeResponseKey = {
	challenge(data: Uint8Array): Promise<Uint8Array>;
};
export type KdbxKey = KdbxProcessedKey | KdbxFileKey | KdbxChallengeResponseKey;
export type KdbxCompositeKey = Uint8Array;
export function createChallengeResponseKey(challenge: (data: Uint8Array) => Promise<Uint8Array>): KdbxChallengeResponseKey;
export function createFileKey(bytes: Uint8Array): Promise<KdbxFileKey>;
export function createPasswordKey(password: string): Promise<KdbxPasswordKey>;
export function parseKdbxHeader(fileBytes: Buffer | Uint8Array | number[]): KdbxOuterHeader & {
	size: number;
};
export type KdbxReadResult = {
	compositeKey: Uint8Array;
	file: KdbxFile;
};
export function readKdbxFile(keys: KdbxKey[] | KdbxCompositeKey, fileBytes: Buffer | Uint8Array | number[]): Promise<KdbxReadResult>;
export type KdbxWriteResult = {
	bytes: Uint8Array;
	compositeKey: Uint8Array;
};
export function writeKdbxFile(keys: KdbxKey[], file: KdbxFile): Promise<KdbxWriteResult>;

export {};
